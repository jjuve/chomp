#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <iostream>
#include "lexer.h"
#include "parser.h"
#include "parse_tree_nodes.h"

using namespace std;

int nextToken = 0; // hold nextToken returned by lex

// Which tree level are we currently in?
static int level = 0;
bool printParse = false;
bool printSymbolMap = false;

static float initialVal = 0.0;

// Feel free to use a different data structure for the symbol table (list of
// variables declared in the program) but you will have to adjust the code in
// main() to print out the symbol table after a successful parse
//set<string> symbolTable; // Symbol Table

//*****************************************************************************
// Indent to reveal tree structure
string psp(void)
{ // Stands for p-space, but I want the name short
  string str("");
  for (int i = 0; i < level; i++)
    str += "|  ";
  return str;
}

//*****************************************************************************
// Report what we found
void output(string what)
{
  if (printParse) cout << psp() << "found |" << yytext << "| " << what << endl;
}

//*****************************************************************************
// Forward declarations of FIRST_OF functions.  These check whether the current
// token is in the FIRST set of a production rule.
bool first_of_program(void);
bool first_of_block(void);
bool first_of_statement(void);
bool first_of_compound_statement(void);
bool first_of_expression(void);
bool first_of_simple_expression(void);
bool first_of_term(void);
bool first_of_factor(void);
//*****************************************************************************

// #########################################################
SimpleExpNode* simple_expression();
ExpressionNode* expression();
StatementNode* statement();
AssignmentStmtNode* assignment_statement();
CompoundStmtNode* compound_statement();
IfStmtNode* if_statement();
WhileStmtNode* while_statement();
ReadStmtNode* read_statement();
WriteStmtNode* write_Statement();
BlockNode* block();
TermNode* term();
FactorNode* factor();
// ################################################

void lex()
{
  nextToken = yylex();
}

/*bool in_symbol_table(string idName)
{
  set<string>::iterator it;
  it = symbolTable.find(idName);
  return !(it == symbolTable.end());
}*/
bool in_symbol_table(const string& idName) {
    auto it = symbolMap.find(idName);  // Using auto for iterator declaration
    return it != symbolMap.end();      // Check if the iterator points to end (not found)
}

// Parses strings in the language generated by the rule:
// <program> â†’ TOK_PROGRAM TOK_IDENT TOK_SEMICOLON <block>
ProgramNode* program()
{
  if (!first_of_program()) // Check for PROGRAM
    throw "3: 'PROGRAM' expected";

  output("PROGRAM");

  lex();

  if (printParse) cout << psp() << "enter <program>" << endl;
  ++level;

  ProgramNode* newProgramNode = nullptr;

  // TODO: finish this parsing function...

  if (nextToken == TOK_IDENT)
  {
    output("IDENTIFIER");
    lex();
  }
  else {throw ("3: 'IDENTIFIER' expected");}

  if (nextToken == TOK_SEMICOLON)
  {
    output("SEMICOLON");
    lex();
  }
  else {throw ("51: ';' expected");}

        BlockNode* blockNode = block();
        newProgramNode = new ProgramNode(level, blockNode);

  --level;
  if (printParse) cout << psp() << "exit <program>" << endl;

  return newProgramNode;
}

// ############################################################################
// Added Functions
// ############################################################################

FactorNode* factor()
{
  if (!first_of_factor())
    throw("903: illegal type of factor");

  output("FACTOR");

  if (printParse) cout << psp() << "enter <factor>" << endl;
  ++level;

  FactorNode* newFactorNode = nullptr;

  switch (nextToken)
  {
  case TOK_INTLIT:
    output("INTLIT");
    if (printParse) cout << psp() << yytext << endl;
    newFactorNode = new IntLitNode(level, atoi(yytext));
    lex();
    break;
  case TOK_FLOATLIT:
    output("FLOATLIT");
    if (printParse) cout << psp() << yytext << endl;
    newFactorNode = new FloatLitNode(level, atof(yytext));
    lex();
    break;
  case TOK_IDENT:{
    output("IDENTIFIER");
    if (printParse) cout << psp() << yytext << endl;

    string* identifier = new string(yytext); 
    newFactorNode = new IdentNode(level, identifier);

    if (!in_symbol_table(yytext))
    {
      if (printParse) cout << endl
           << "***ERROR:" << endl;
      if (printParse) cout << "On line number " << yylineno << ", near |" << yytext << "|, error type 104: identifier not declared" << endl;
      delete identifier;
      exit(1);
    }

    lex();
  }
    break;
  case TOK_OPENPAREN:
    output("OPENPAREN");
    if (printParse) cout << psp() << yytext << endl;
    lex();
    output("EXPRESSION");

    newFactorNode = new NestNode(level, expression());

    output("CLOSEPAREN");

    lex();

    break;
  case TOK_NOT:
    output("NOT");
    if (printParse) cout << psp() << yytext << endl;
    lex();
    newFactorNode = new NotNode(level, factor());
    break;
  case TOK_MINUS:
    output("MINUS");
    if (printParse) cout << psp() << yytext << endl;
    lex();
    newFactorNode = new MinusNode(level, factor());
    break;
  }

  --level;
  if (printParse) cout << psp() << "exit <factor>" << endl;

  return newFactorNode;
}

TermNode* term()
{
  if (!first_of_term())
  {
    throw("902: illegal type of term ");
  }

  output("TERM");

  if (printParse) cout << psp() << "enter <term>" << endl;
  ++level;
  
  FactorNode* firstFactor= factor();
  TermNode* newTermNode = new TermNode(level, firstFactor);


  while (nextToken == TOK_MULTIPLY || nextToken == TOK_DIVIDE || nextToken == TOK_AND)
  {
    int op = nextToken;
    if (nextToken == TOK_MULTIPLY)
    {
      output("MULTIPLY");
      if (printParse) cout << psp() << yytext << endl;
    }
    else if (nextToken == TOK_DIVIDE)
    {
      output("DIVIDE");
      if (printParse) cout << psp() << yytext << endl;
    }
    else if (nextToken == TOK_AND)
    {
      output("AND");
      if (printParse) cout << psp() << yytext << endl;
    }

    lex();

    FactorNode* firstFactor= factor();
    newTermNode->restFactor.push_back(firstFactor);
    newTermNode->restFactorOps.push_back(op);
  }

  --level;
  if (printParse) cout << psp() << "exit <term>" << endl;

  return newTermNode;
}

BlockNode* block()
{

  string idName;
  string idType;

  if (!first_of_block())
    throw("18: error in declaration part OR 17: 'BEGIN' expected");
  output("BLOCK");

  if (printParse) cout << psp() << "enter <block>" << endl;
  ++level;

  BlockNode* newBlockNode = nullptr;

  if (nextToken == TOK_VAR)
  {
    lex();

    while (nextToken != TOK_BEGIN)
    {
      if (nextToken == TOK_IDENT)
      {
        output("IDENTIFIER");
        idName = yytext;
        lex();
      }
      if (nextToken == TOK_COLON)
      {
        output("COLON");
        lex();
      }
      if (nextToken == TOK_REAL)
      {
        output("TYPE");
        idType = yytext;
        lex();
      }
      if (nextToken == TOK_INTEGER)
      {
        output("TYPE");

        idType = yytext;
        lex();
      }

      if (nextToken == TOK_SEMICOLON)
      {

        output("SEMICOLON");
      }

      if (printParse) cout << psp() << "-- idName: |" << idName << "| idType: |" << idType << "| --" << endl;

      if (!in_symbol_table(idName))
      {
        //symbolTable.insert(idName);
        symbolMap.insert(pair<string, float>(idName, initialVal));
      }
      else
      {
        throw("101: identifier declared twice");
      }
      lex();
    }
  }

  output("BEGIN");
  
  CompoundStmtNode* compoundStmtNode  = compound_statement();
  newBlockNode = new BlockNode(level, compoundStmtNode);

  --level;
  if (printParse) cout << psp() << "exit <block>" << endl;

  return newBlockNode;
}

StatementNode* statement()
{
  if (!first_of_statement())
    throw("900: illegal type of statement");

  StatementNode* newStatementNode = nullptr;

  output("STATEMENT");

  switch (nextToken)
  {
  case TOK_IDENT:
    newStatementNode = assignment_statement();
    break;
  case TOK_BEGIN:
    output("BEGIN");
    newStatementNode = compound_statement();
    break;
  case TOK_IF:
    newStatementNode = if_statement();
    break;
  case TOK_WHILE:
    newStatementNode = while_statement();
    break;
  case TOK_READ:
    newStatementNode = read_statement();
    break;
  case TOK_WRITE:
    newStatementNode = write_Statement();
    break;
  }

  return newStatementNode;
}

AssignmentStmtNode* assignment_statement()
{
  if (printParse) cout << psp() << "enter <assignment>" << endl;
  ++level;
  AssignmentStmtNode* newAssignmentStmtNode = nullptr;
  newAssignmentStmtNode = new AssignmentStmtNode(level);

  if (nextToken != TOK_IDENT)
    throw "2: identifier expected";

  output("IDENTIFIER");

  if (printParse) cout << psp() << yytext << endl;

  newAssignmentStmtNode->ident = string(yytext);
  
  lex();

  output("ASSIGN");

  lex();

  output("EXPRESSION");

  newAssignmentStmtNode->expression = expression();

  --level;
  if (printParse) cout << psp() << "exit <assignment>" << endl;
 
  return newAssignmentStmtNode;
}

CompoundStmtNode* compound_statement()
{
  if (!first_of_compound_statement())
    throw "17: 'BEGIN' expected";

  if (printParse) cout << psp() << "enter <compound_stmt>" << endl;
  ++level;
  
  CompoundStmtNode* newCompoundStmtNode = nullptr;
  newCompoundStmtNode = new CompoundStmtNode(level);

  lex();
  StatementNode* stmt = statement();
  newCompoundStmtNode->statements.push_back(stmt);
 
  while (nextToken == TOK_SEMICOLON)
  {
    output("SEMICOLON");
    lex();
    if (nextToken == TOK_END)
    {
      break;
    }
    newCompoundStmtNode->statements.push_back(statement());
  }

  --level;

  output("END");
  lex();

  if (printParse) cout << psp() << "exit <compound_stmt>" << endl;

  return newCompoundStmtNode;
}

IfStmtNode* if_statement()
{
  if (printParse) cout << psp() << "enter <if>" << endl;
  ++level;

  IfStmtNode* newIfStmtNode = nullptr;
  newIfStmtNode = new IfStmtNode(level);

  lex();

  output("EXPRESSION");

  newIfStmtNode->ifstatement = expression();

  if (nextToken == TOK_THEN)
  {
    --level;
    output("THEN");
    lex();
    if (printParse) cout << psp() << "enter <then>" << endl;
    ++level;

    newIfStmtNode->thenstatement = statement();


    --level;

    if (printParse) cout << psp() << "exit <then>" << endl;

    if (nextToken == TOK_ELSE)
    {

      output("ELSE");
      lex();
      if (printParse) cout << psp() << "enter <else>" << endl;
      ++level;
      newIfStmtNode->elsestatement = statement();
      --level;
      if (printParse) cout << psp() << "exit <else>" << endl;
      ++level;
    }
  }
  else
    throw("52: 'THEN' expected");

  --level;
  if (printParse) cout << psp() << "exit <if>" << endl;
  return newIfStmtNode;
}

WhileStmtNode* while_statement()
{
  if (printParse) cout << psp() << "enter <while>" << endl;
  ++level;
  
  WhileStmtNode* newWhileStmtNode = new WhileStmtNode(level);


  lex();

  output("EXPRESSION");

  newWhileStmtNode->condition = expression();

  newWhileStmtNode->body = statement();

  --level;
  if (printParse) cout << psp() << "exit <while>" << endl;
  return newWhileStmtNode;
}

ReadStmtNode* read_statement()
{
  if (printParse) cout << psp() << "enter <read>" << endl;
  ++level;
  ReadStmtNode* newReadStmtNode = nullptr;
  newReadStmtNode = new ReadStmtNode(level);

  lex();

  if (nextToken == TOK_OPENPAREN)
  {
    output("OPENPAREN");
    lex();
  }

  if (nextToken == TOK_IDENT)
  {
    output("IDENTIFIER");
  }

  if (printParse) cout << psp() << yytext << endl;
  newReadStmtNode->var =string(yytext);

  lex();

  if (nextToken == TOK_CLOSEPAREN)
  {
    output("CLOSEPAREN");
  }

  lex();

  --level;
  if (printParse) cout << psp() << "exit <read>" << endl;
return newReadStmtNode;
}

WriteStmtNode* write_Statement()
{

  if (printParse) cout << psp() << "enter <write>" << endl;
  ++level;
  WriteStmtNode* newWriteStmtNode = nullptr;
  newWriteStmtNode = new WriteStmtNode(level);
  

  lex();

  if (nextToken == TOK_OPENPAREN)
  {
    output("OPENPAREN");
    lex();
  }
  newWriteStmtNode->type = nextToken;
  if (nextToken == TOK_IDENT)
  {
    output("WRITE");
    newWriteStmtNode->content = string(yytext);
  }
  else if (nextToken == TOK_STRINGLIT)
  {
    output("WRITE");
    newWriteStmtNode->content =string(yytext);
  }

  if (printParse) cout << psp() << yytext << endl;

  lex();

  if (nextToken == TOK_CLOSEPAREN)
  {
    output("CLOSEPAREN");
  }

  lex();

  --level;
  if (printParse) cout << psp() << "exit <write>" << endl;

  return newWriteStmtNode;
}

ExpressionNode* expression()
{
  if (!first_of_expression())
    throw("144: illegal type of expression");

  if (printParse) cout << psp() << "enter <expression>" << endl;
  ++level;

  SimpleExpNode* firstExp = simple_expression();
  ExpressionNode* newExpressionNode = new ExpressionNode(level, firstExp);

  if (nextToken == TOK_EQUALTO || nextToken == TOK_LESSTHAN ||
      nextToken == TOK_GREATERTHAN || nextToken == TOK_NOTEQUALTO)
  {
    int op = nextToken;
    switch (nextToken)
    {
    case TOK_EQUALTO:
      output("EQUALTO");
      if (printParse) cout << psp() << yytext << endl;
      newExpressionNode->restSimpleExp.push_back(op);
      lex();
      newExpressionNode->restSimple.push_back(simple_expression());
      break;
    case TOK_LESSTHAN:
      output("LESSTHAN");
      if (printParse) cout << psp() << yytext << endl;
      newExpressionNode->restSimpleExp.push_back(op);
      lex();
      newExpressionNode->restSimple.push_back(simple_expression());
      break;
    case TOK_GREATERTHAN:
      output("GREATERTHAN");
      if (printParse) cout << psp() << yytext << endl;
      newExpressionNode->restSimpleExp.push_back(op);
      lex();
      newExpressionNode->restSimple.push_back(simple_expression());
      break;
    case TOK_NOTEQUALTO:
      output("NOTEQUALTO");
      newExpressionNode->restSimpleExp.push_back(op);
      lex();
      newExpressionNode->restSimple.push_back(simple_expression());
      break;
    }
    
  }

  --level;
  if (printParse) cout << psp() << "exit <expression>" << endl;

  return newExpressionNode;
}

SimpleExpNode* simple_expression()
{
  if (!first_of_simple_expression())
    throw("901: illegal type of simple expression");

  output("SIMPLE_EXP");

  if (printParse) cout << psp() << "enter <simple_exp>" << endl;
  ++level;

  TermNode* firstTerm = term();
  SimpleExpNode* newSimpleExpNode = new SimpleExpNode(level, firstTerm);

  while (nextToken == TOK_PLUS || nextToken == TOK_MINUS || nextToken == TOK_OR)
  {
    int op = nextToken;
    if (nextToken == TOK_PLUS)
    {
      output("PLUS");
      if (printParse) cout << psp() << yytext << endl;
    }
    else if (nextToken == TOK_MINUS)
    {
      output("MINUS");
      if (printParse) cout << psp() << yytext << endl;
    }
    else if (nextToken == TOK_OR)
    {
      output("OR");
      if (printParse) cout << psp() << yytext << endl;
    }

    lex();

    TermNode* nextTerm = term();  
    newSimpleExpNode->restTerm.push_back(nextTerm);  
    newSimpleExpNode->restTermOps.push_back(op);  
  }

  --level;

  if (printParse) cout << psp() << "exit <simple_exp>" << endl;
  
  return newSimpleExpNode;
}

// ################################################################################################

// firstoffunctions
bool first_of_program(void)
{
  return nextToken == TOK_PROGRAM;
}
bool first_of_block(void)
{
  return nextToken == TOK_VAR || nextToken == TOK_BEGIN;
}
bool first_of_statement(void)
{
  return nextToken == TOK_IDENT || nextToken == TOK_BEGIN || nextToken == TOK_IF || nextToken == TOK_WHILE || nextToken == TOK_READ || nextToken == TOK_WRITE;
}
bool first_of_compound_statement(void)
{
  return nextToken == TOK_BEGIN;
}
bool first_of_expression(void)
{
  return first_of_simple_expression();
}
bool first_of_simple_expression(void)
{
  return first_of_term();
}
bool first_of_term(void)
{
  return first_of_factor();
}
bool first_of_factor(void)
{
  return nextToken == TOK_INTLIT || nextToken == TOK_FLOATLIT || nextToken == TOK_IDENT || nextToken == TOK_OPENPAREN || nextToken == TOK_NOT || nextToken == TOK_MINUS;
}
